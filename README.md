# CS50-Final-Project

This is my Final Project submission for the CS50x Course.

## What does it do?
The idea is simple: to calculate the electronic configuration and the properties of any element given its atomic number and output it on the screen.

## How does it accomplish it?
The main function is housed inside the `elec_config.py` Python file, which imports data about all 118 existing elements from `elec_config_data.py`. The main function is `electronicConfiguration(n)`, which requires one parameter `n`, which is an integer that contains the atomic number of the required element. The calculation takes place using subshells, orbital notations and the total number of elements in each shell and orbital.
There also two helper functions, `iupacName(n)` and `elemSearch(n)`, both of which make use of the atomic number of the required element. `elemSearch(n)` searches the dictionary of lists, `elements`, which was imported from `elec_config_data.py`, for the name and symbol of the given atomic number among the existing 118 elements. If it does not exist in `elements`, a name and symbol for the given atomic number is generated by the `iupacName(n)` function, using the conventions laid out by the International Union of Pure and Applied Chemistry (IUPAC).
The functions `electronicConfiguration(n)`, `elemSearch(n)` and `iupacName(n)` are called inside `app.py` to find the electronic configuration of the atomic number input by the user using a form in `index.html`. The generated output is returned to the user through `index.html` using a POST request via Flask.
Additionally, I use the `mendeleev` library written in Python to query various properties of the elements using the atomic number input by the user, and display them on the page along with the electronic configuration.

### app.py
`app.py`'s main function is to establish the connectivity between the Python backend and HTML/CSS frontend via the Flask framework and communicate between the two aspects of the project. `app.py` imports various functions from `elec_config.py` and `elec_config_data.py` to calculate the output to be sent to `indexed.html`, which is the template that is rendered for output. `app.py` also imports `mendeleev`, which is a Python library that contains an extensive dataset of the properties of all 118 existing elements, such as `mass`, `density`, `melting_point`, `boiling_point` to name a few. These can be accessed using the `class` and `attribute` notations. If the input from `index.html` (which is the template rendered with the `form` to take in the atomic number as input) lies between 1 and 118, properties of the element are accessed using the `mendeleev` library and outputted in the form of a Bootstrap `card` in the `indexed.html` page.

### elec_config.py
`elec_config.py` is the main piece of Python code doing all the heavylifting underneath the hood. The primary function for calculating the Electronic Configuration of the element is `electronicConfiguration(n)`, where `n` is the parameter containing the atomic number. The other functions are `key(dict, elem)`, `superscript(x)`, `iupacName(n)`, `elemSearch(n)` and `elemSymbol(n)` which are explained forthwith.

#### electronicConfiguration(n)
This is the main function that calculates the electronic configuration of the element using its atomic number. Firstly, it handles two exceptions, `n == 24` and `n == 29`, for Chromium and Copper respectively. These two elements have an exceptional electronic configuration, due to the higher stability of the 4s¹ 3d⁵ and 4s¹ 3d¹⁰ configurations respectively, as compared to the expected electronic configuration. The electronic configuration of the other elements is calculated using the total number of electrons (i.e, the atomic number, `n`), and various subshells. Each subshell can only hold a fixed number of electrons in fixed orbitals, as denoted in the `electrons` dictionary in `elec_config.py`, and each shell can only have a fixed number of subshells. These subshell and orbital configurations are created and sorted in the `subshells` list, which is accessed and iterated upon in `electronicConfiguration(n)`. Subsequently, electrons are "filled" in each orbital, and once it is "fully-filled", the leftover electrons are moved forward to the next one, until no more electrons are left. A string containing the final electronic configuration is returned from the function.

#### key(dict, elem)
This is a function to improve the quality and abstraction of the code, and the main purpose is to return the key of a dictionary element using its value. `dict` is the dictionary and `elem` is the value whose key is to be found.

#### superscript(x)
This is another quality-improvement function. It returns a number in the superscript form, in order to process the output in the proper IUPAC notation. `x` is the only parameter, the number which is to be returned in superscript.

#### iupacName(n)
If the atomic number input by the user is more than 118 (that is, if the element is undiscovered), its name is processed as per the nomenclature conventions laid out by the IUPAC. `n` is the atomic number. This function is called inside a conditional, if and only if `n` > 118.

#### elemSearch(n)
If the atomic number input by the user is between 1 and 118 (that is, if the element has already been discovered), its name is found using the `elements` dictionary in `elec_config_data.py`. `n` is the atomic number. This function is called inside a conditional, if and only if 1 < `n` < 118.

#### elemSymbol(n)
This function returns the elemental symbol (e.g. H for Hydrogen, Na for Sodium) using the atomic number, `n`.

### elec_config_data.py
This Python file contains two data structures, a dictionary of lists `elements` containing elements sorted by their atomic numbers and containing their names and number of electrons in each shell, and a dictionary `elements1`, which contains key-value pairs for elements and their names for quick access.

### layout.html
This is the layout template for the webpage. It imports Bootstrap CSS and JS, and renders the page elements to be viewed globally.

### index.html
This is the template rendered when a GET request is made, that is to say, this template contains the form which inputs the atomic number on which the electronic configuration calculation is done.

### indexed.html
This is the templated rendered when a POST request is made, that is to say, this template renders the entire output, i.e., the element's name, its electronic configuration and other important properties of the elements retrieved through the `mendeleev` library in `app.py`.

### styles.css
This is the stylesheet, which sets the dark background theme, white text, center alignment and custom fonts, which are imported from Google.